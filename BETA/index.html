<!DOCTYPE html>
<html lang="tr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Three.js Canvas Origami (GerÃ§ek 3D)</title>
<style>
    body { margin: 0; overflow: hidden; background-color: #2c3e50; font-family: sans-serif; }
    #info {
        position: absolute; top: 10px; width: 100%; text-align: center; color: white;
        pointer-events: none; /* YazÄ±nÄ±n tÄ±klamayÄ± engellememesi iÃ§in */
        text-shadow: 1px 1px 2px black;
    }
    #controls {
        position: absolute; bottom: 20px; width: 100%; text-align: center;
    }
    button {
        padding: 10px 25px; font-size: 16px; cursor: pointer; background: #e74c3c; color: white; border: none; border-radius: 5px;
    }
</style>
</head>
<body>

<div id="info">
    ğŸ‘† <b>Canvas Modu:</b> KaÄŸÄ±dÄ±n Ã¼zerine Ã§izgi Ã§ek ve bÄ±rak. <br>GerÃ§ek 3D geometri, lag yok!
</div>

<div id="controls">
    <button onclick="resetPaper()">KaÄŸÄ±dÄ± SÄ±fÄ±rla</button>
</div>

<script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.160.0/build/three.module.js"
    }
  }
</script>

<script type="module">
import * as THREE from 'three';

let scene, camera, renderer;
let paperMesh, lineHelper;
let raycaster = new THREE.Raycaster();
let pointer = new THREE.Vector2();
let isDrawing = false;
let startPoint = new THREE.Vector3();
let endPoint = new THREE.Vector3();

init();
animate();

function init() {
    // 1. SAHNE KURULUMU
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x2c3e50);

    // 2. KAMERA
    camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 1000);
    camera.position.set(0, 15, 20); // YukarÄ±dan ve Ã§aprazdan bak
    camera.lookAt(0, 0, 0);

    // 3. IÅIKLAR (GerÃ§ekÃ§ilik iÃ§in Ã¶nemli)
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
    dirLight.position.set(10, 20, 10);
    dirLight.castShadow = true;
    scene.add(dirLight);

    // 4. RENDERER (Canvas'Ä± oluÅŸturan motor)
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.shadowMap.enabled = true;
    document.body.appendChild(renderer.domElement);

    // 5. KAÄIDI OLUÅTUR
    createPaper();

    // 6. Ã‡Ä°ZÄ°M YARDIMCISI Ã‡Ä°ZGÄ°
    const lineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
    const lineGeometry = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(), new THREE.Vector3()]);
    lineHelper = new THREE.Line(lineGeometry, lineMaterial);
    lineHelper.visible = false;
    scene.add(lineHelper);

    // OLAY DÄ°NLEYÄ°CÄ°LERÄ°
    window.addEventListener('resize', onWindowResize);
    renderer.domElement.addEventListener('pointerdown', onPointerDown);
    renderer.domElement.addEventListener('pointermove', onPointerMove);
    renderer.domElement.addEventListener('pointerup', onPointerUp);
}

function createPaper() {
    if (paperMesh) scene.remove(paperMesh);

    // KaÄŸÄ±t iÃ§in bol segmentli bir dÃ¼zlem (PlaneGeometry) oluÅŸturuyoruz.
    // Ne kadar Ã§ok segment (25, 25) o kadar pÃ¼rÃ¼zsÃ¼z katlama, ama iÅŸlem yÃ¼kÃ¼ artar.
    const geometry = new THREE.PlaneGeometry(16, 10, 30, 30);
    
    // KaÄŸÄ±dÄ±n iki yÃ¼zÃ¼ iÃ§in malzeme. Arka yÃ¼zÃ¼ farklÄ± renk yapalÄ±m ki katlandÄ±ÄŸÄ± belli olsun.
    const materialFront = new THREE.MeshStandardMaterial({ 
        color: 0xfdf5e6, // Krem rengi Ã¶n yÃ¼z
        side: THREE.FrontSide,
        roughness: 0.6,
        metalness: 0.1
    });
     const materialBack = new THREE.MeshStandardMaterial({ 
        color: 0xe67e22, // Turuncu arka yÃ¼z
        side: THREE.BackSide,
        roughness: 0.8
    });

    // Ä°ki malzemeyi birleÅŸtirip mesh oluÅŸturuyoruz
    paperMesh = new THREE.Group();
    const frontMesh = new THREE.Mesh(geometry, materialFront);
    const backMesh = new THREE.Mesh(geometry.clone(), materialBack);
    // Arka yÃ¼zÃ¼ Ã§ok az geriye itiyoruz ki Ã§akÄ±ÅŸmasÄ±nlar (Z-fighting Ã¶nlemi 1)
    backMesh.position.z = -0.001; 
    
    paperMesh.add(frontMesh);
    paperMesh.add(backMesh);

    paperMesh.rotation.x = -Math.PI / 2; // KaÄŸÄ±dÄ± yere yatÄ±r
    paperMesh.receiveShadow = true;
    paperMesh.castShadow = true;
    scene.add(paperMesh);
}

// --- ETKÄ°LEÅÄ°M FONKSÄ°YONLARI ---

function getIntersects(event) {
    // Fare pozisyonunu -1 ile 1 arasÄ±na normalize et
    pointer.x = (event.clientX / window.innerWidth) * 2 - 1;
    pointer.y = -(event.clientY / window.innerHeight) * 2 + 1;
    // Kameradan fare ucuna Ä±ÅŸÄ±n gÃ¶nder (Raycasting)
    raycaster.setFromCamera(pointer, camera);
    // IÅŸÄ±n kaÄŸÄ±da deÄŸdi mi kontrol et
    return raycaster.intersectObjects(paperMesh.children, true);
}

function onPointerDown(event) {
    const intersects = getIntersects(event);
    if (intersects.length > 0) {
        isDrawing = true;
        // TÄ±klanan noktayÄ± dÃ¼nya koordinatlarÄ±nda al
        startPoint.copy(intersects[0].point);
        // Ã‡izgi yardÄ±mcÄ±sÄ±nÄ± baÅŸlat
        lineHelper.geometry.setFromPoints([startPoint, startPoint]);
        lineHelper.visible = true;
    }
}

function onPointerMove(event) {
    if (!isDrawing) return;
    const intersects = getIntersects(event);
    if (intersects.length > 0) {
        const currentPoint = intersects[0].point;
        // Ã‡izgi yardÄ±mcÄ±sÄ±nÄ± gÃ¼ncelle
        lineHelper.geometry.setFromPoints([startPoint, currentPoint]);
        lineHelper.geometry.attributes.position.needsUpdate = true;
    }
}

function onPointerUp(event) {
    if (!isDrawing) return;
    isDrawing = false;
    lineHelper.visible = false;

    const intersects = getIntersects(event);
    if (intersects.length > 0) {
        endPoint.copy(intersects[0].point);
        // EÄŸer Ã§izgi Ã§ok kÄ±saysa iÅŸlem yapma
        if (startPoint.distanceTo(endPoint) < 0.5) return;
        
        // KATLAMA Ä°ÅLEMÄ°NÄ° BAÅLAT
        performFold(startPoint, endPoint);
    }
}

// --- CORE: KATLAMA MATEMATÄ°ÄÄ° ---
function performFold(startWorld, endWorld) {
    // KaÄŸÄ±t mesh'lerinin geometrilerine eriÅŸ
    paperMesh.children.forEach(mesh => {
        const geometry = mesh.geometry;
        const positions = geometry.attributes.position.array;
        
        // 1. DÃ¼nya koordinatÄ±ndaki noktalarÄ± kaÄŸÄ±dÄ±n yerel (local) koordinatÄ±na Ã§evir
        const startLocal = mesh.worldToLocal(startWorld.clone());
        const endLocal = mesh.worldToLocal(endWorld.clone());

        // 2. Katlama vektÃ¶rÃ¼ ve normalini hesapla
        const foldVector = new THREE.Vector3().subVectors(endLocal, startLocal).normalize();
        // KaÄŸÄ±t dÃ¼zleminde katlama Ã§izgisine dik bir vektÃ¶r (Z ekseni etrafÄ±nda 90 derece dÃ¶nÃ¼ÅŸ)
        const perpendicularVector = new THREE.Vector3(-foldVector.y, foldVector.x, 0).normalize();
        
        // 3. DÃ¶ndÃ¼rme Matrisi HazÄ±rla (Katlama Ã§izgisi ekseninde 180 derece)
        // Z-fighting'i Ã¶nlemek iÃ§in tam 180 (Math.PI) deÄŸil, Ã§ok az eksiÄŸini yapÄ±yoruz.
        const rotationAngle = Math.PI - 0.01; 
        const rotationMatrix = new THREE.Matrix4().makeRotationAxis(foldVector, rotationAngle);

        // 4. TÃ¼m kÃ¶ÅŸeleri (vertex) gez
        for (let i = 0; i < positions.length; i += 3) {
            const vertex = new THREE.Vector3(positions[i], positions[i+1], positions[i+2]);
            
            // KÃ¶ÅŸenin katlama Ã§izgisinin hangi tarafÄ±nda olduÄŸunu bul (Dot Product)
            const vecToVertex = new THREE.Vector3().subVectors(vertex, startLocal);
            const side = vecToVertex.dot(perpendicularVector);

            // EÄŸer Ã§izginin "aktif" tarafÄ±ndaysa dÃ¶ndÃ¼r
            if (side > 0.001) {
                // DÃ¶nÃ¼ÅŸ merkezini orijine taÅŸÄ±
                vertex.sub(startLocal);
                // DÃ¶ndÃ¼r
                vertex.applyMatrix4(rotationMatrix);
                // Tekrar eski yerine taÅŸÄ±
                vertex.add(startLocal);

                // Z-Fighting Ã–nlemi 2: Katlanan kÄ±smÄ± kaÄŸÄ±dÄ±n normali yÃ¶nÃ¼nde (Z ekseni) Ã§ok az yukarÄ± kaldÄ±r.
                // Bu sayede katlanan yÃ¼zey alttakinin iÃ§ine girmez.
                vertex.z += 0.02; 

                // Yeni pozisyonlarÄ± kaydet
                positions[i] = vertex.x;
                positions[i+1] = vertex.y;
                positions[i+2] = vertex.z;
            }
        }
        // Three.js'e geometrinin deÄŸiÅŸtiÄŸini bildir
        geometry.attributes.position.needsUpdate = true;
        geometry.computeVertexNormals(); // IÅŸÄ±klandÄ±rmayÄ± dÃ¼zelt
    });
}

function onWindowResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}

function animate() {
    requestAnimationFrame(animate);
    renderer.render(scene, camera);
}

// HTML'den eriÅŸilebilmesi iÃ§in window nesnesine ekle
window.resetPaper = createPaper;

</script>
</body>
</html>
